<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Ciudad 3D · Lotes rojo/verde (sin HUD, sin niebla)</title>
  <style>
    html,body{margin:0;height:100%;overflow:hidden;background:#ffffff;}
    canvas{display:block}
  </style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
<script>
// ===================== CONFIG BÁSICA =====================
const CFG = {
  tile: 1.7,            // tamaño base de cada bloque (x,z)
  gap:  0.65,           // separación
  minH: 0.35,           // altura mínima
  maxH: 10.5,           // altura máxima
  grid: 160,            // grilla máxima (se aplican límites abajo)
  domainScale: 0.6,     // escala de coordenadas para ondas

  // Transiciones por lotes (pocas y lentas)
  speed: 0.65,          // velocidad de cambio (unid. altura / seg)
  spawnPerSec: 140,     // activaciones nuevas por segundo
  maxConcurrent: 900,   // máximo activas simultáneas

  // Colores de estado (lineal 0..1)
  riseRGB: [0.20, 0.90, 0.30], // verde al subir
  dropRGB: [0.96, 0.20, 0.18]  // rojo al bajar
};

// ===================== LIMITES DEL MAPA (EDITAR AQUÍ) =====================
// Define qué parte del grid se renderiza realmente.
const AREA = {
  shape: "circle",      // "circle" | "square"
  radiusTiles: 70,      // si shape="circle": radio en N° de tiles (centro en 0,0)
  halfSizeTiles: 70     // si shape="square": semilado en N° de tiles
};

// ===================== ZOOM / CÁMARA (EDITAR AQUÍ) =====================
// Limita cuán cerca/lejos y alto/bajo está la cámara. No hay controles de usuario.
const CAM = {
  radius: 105,          // distancia inicial al objetivo
  minRadius: 80,        // límite mínimo de distancia
  maxRadius: 140,       // límite máximo de distancia
  height: 85,           // altura inicial
  minHeight: 60,        // límite mínimo de altura
  maxHeight: 120,       // límite máximo de altura
  fov: 60,              // campo de visión (grados)
  minFov: 45,           // FOV mínimo
  maxFov: 75,           // FOV máximo
  autorotate: 0.045,    // rad/seg de giro (lento, fijo)
  targetOffset: new THREE.Vector3(6,0,0) // leve desplazamiento del centro
};

// ===================== ESCENA (sin niebla, sin HUD, sin inputs) =====================
const scene = new THREE.Scene();

const camera = new THREE.PerspectiveCamera(
  THREE.MathUtils.clamp(CAM.fov, CAM.minFov, CAM.maxFov),
  innerWidth/innerHeight, 0.1, 3000
);
CAM.radius = THREE.MathUtils.clamp(CAM.radius, CAM.minRadius, CAM.maxRadius);
CAM.height = THREE.MathUtils.clamp(CAM.height, CAM.minHeight, CAM.maxHeight);

let camAngle = Math.PI*0.15; // ligera inclinación orbital
function placeCamera(){
  const x = Math.sin(camAngle)*CAM.radius + CAM.targetOffset.x;
  const z = Math.cos(camAngle)*CAM.radius + CAM.targetOffset.z;
  camera.position.set(x, CAM.height, z);
  camera.lookAt(CAM.targetOffset);
}
placeCamera();

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth, innerHeight);
renderer.setPixelRatio(Math.min(devicePixelRatio,2));
renderer.setClearColor(0xffffff, 1);
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.0;
document.body.appendChild(renderer.domElement);

// Iluminación para fondo blanco
scene.add(new THREE.HemisphereLight(0xffffff, 0xdfe6f3, 0.85));
const sun = new THREE.DirectionalLight(0xffffff, 0.9);
sun.position.set(60, 120, -40);
scene.add(sun);

// ===================== GEOMETRÍA (InstancedMesh) =====================
const step = CFG.tile + CFG.gap;

// ---- Construir lista de celdas visibles según AREA ----
const offset = (CFG.grid - 1) / 2;
const posXArr = [], posZArr = [], domXArr = [], domZArr = [];
for(let zi=0; zi<CFG.grid; zi++){
  for(let xi=0; xi<CFG.grid; xi++){
    const dx = xi - offset, dz = zi - offset;
    const inCircle = (dx*dx + dz*dz) <= (AREA.radiusTiles*AREA.radiusTiles);
    const inSquare = Math.abs(dx)<=AREA.halfSizeTiles && Math.abs(dz)<=AREA.halfSizeTiles;
    const inside = (AREA.shape==="circle") ? inCircle : inSquare;
    if(!inside) continue;

    posXArr.push(dx*step);
    posZArr.push(dz*step);
    domXArr.push(dx*CFG.domainScale);
    domZArr.push(dz*CFG.domainScale);
  }
}

const posX = new Float32Array(posXArr);
const posZ = new Float32Array(posZArr);
const domX = new Float32Array(domXArr);
const domZ = new Float32Array(domZArr);
const COUNT = posX.length;

const boxGeo = new THREE.BoxGeometry(CFG.tile, 1, CFG.tile);

// Material con gradiente por altura + override por instancia (rojo/verde)
const cityMat = new THREE.MeshStandardMaterial({color:0xdce9ff, roughness:0.30, metalness:0.06});
cityMat.onBeforeCompile = (shader)=>{
  shader.vertexShader = shader.vertexShader.replace(
    '#include <common>',
    `#include <common>
     attribute float overrideFlag;   // 0 = normal, 1 = override
     attribute vec3  ovColor;        // color override (rojo/verde)
     varying float vOverride;
     varying vec3  vOvColor;
     varying float vWorldY;`
  ).replace(
    '#include <project_vertex>',
    `#include <project_vertex>
     vWorldY = (modelMatrix * vec4( transformed, 1.0 )).y;
     vOverride = overrideFlag;
     vOvColor   = ovColor;`
  );

  shader.fragmentShader = shader.fragmentShader.replace(
    '#include <common>',
    `#include <common>
     varying float vOverride;
     varying vec3  vOvColor;
     varying float vWorldY;
     vec3 palette(float t){
       // paleta suave cyan→azul→violeta
       vec3 c1=vec3(0.64,0.81,1.00);
       vec3 c2=vec3(0.42,0.56,1.00);
       vec3 c3=vec3(0.84,0.74,1.00);
       vec3 mix1 = mix(c1,c2,smoothstep(0.0,0.6,t));
       return mix(mix1,c3,smoothstep(0.5,1.0,t));
     }`
  ).replace(
    'vec4 diffuseColor = vec4( diffuse, opacity );',
    `float hNorm = clamp((vWorldY - ${CFG.minH.toFixed(2)}) / ${(CFG.maxH-CFG.minH).toFixed(2)}, 0.0, 1.0);
     vec3 grad = palette(hNorm);
     vec3 finalCol = mix(grad, vOvColor, vOverride);
     vec4 diffuseColor = vec4(finalCol, opacity);`
  );
};

const mesh = new THREE.InstancedMesh(boxGeo, cityMat, COUNT);
mesh.instanceMatrix.setUsage(THREE.DynamicDrawUsage);
scene.add(mesh);

// Atributos instanciados para override de color
const overrideAttr = new THREE.InstancedBufferAttribute(new Float32Array(COUNT), 1);
const ovColorAttr  = new THREE.InstancedBufferAttribute(new Float32Array(COUNT*3), 3);
mesh.geometry.setAttribute('overrideFlag', overrideAttr);
mesh.geometry.setAttribute('ovColor', ovColorAttr);

// ===================== ONDAS (CAMPOS DE ALTURA, SIN TIEMPO) =====================
function wave1(x,z){ // radial
  const r = Math.hypot(x,z);
  return 0.5 + 0.45*Math.sin(r*0.35) + 0.15*Math.sin(r*0.10);
}
function wave2(x,z){ // rejilla 2D
  return 0.5 + 0.35*Math.sin(x*0.55) * Math.sin(z*0.45);
}
function wave3(x,z){ // rombos (taxicab)
  const d = Math.abs(x)+Math.abs(z);
  return 0.5 + 0.42*Math.sin(d*0.38);
}
const WAVES = [wave1, wave2, wave3];
let currentWave = 0, nextWave = 1;

// ===================== ESTADO POR INSTANCIA =====================
const H       = new Float32Array(COUNT); // altura actual
const Target  = new Float32Array(COUNT); // objetivo
const Active  = new Uint8Array(COUNT);   // 1 si está cambiando
const Done    = new Uint8Array(COUNT);   // 1 si llegó
const activeList = new Int32Array(COUNT);
let activeLen = 0, activeCount = 0, doneCount = 0;

const TMP = new THREE.Object3D();
function setInstance(i, h){
  TMP.position.set(posX[i], h/2, posZ[i]);
  TMP.scale.set(1, h, 1);
  TMP.updateMatrix();
  mesh.setMatrixAt(i, TMP.matrix);
}
function setOverride(i, flag, rgb){
  overrideAttr.setX(i, flag?1:0);
  if(flag) ovColorAttr.setXYZ(i, rgb[0], rgb[1], rgb[2]);
}

// Inicializar en Onda 1
(function initWave1(){
  const w = WAVES[currentWave];
  for(let i=0;i<COUNT;i++){
    const norm = w(domX[i], domZ[i]);
    const h = THREE.MathUtils.mapLinear(norm, 0, 1, CFG.minH, CFG.maxH);
    H[i] = h;
    setInstance(i, h);
    setOverride(i, 0);
  }
  mesh.instanceMatrix.needsUpdate = true;
  overrideAttr.needsUpdate = true; ovColorAttr.needsUpdate = true;
})();

function prepareTransition(toWaveIdx){
  const w = WAVES[toWaveIdx];
  activeLen = 0; activeCount = 0; doneCount = 0;
  Active.fill(0); Done.fill(0);
  for(let i=0;i<COUNT;i++){
    const norm = w(domX[i], domZ[i]);
    const t = THREE.MathUtils.clamp(
      THREE.MathUtils.mapLinear(norm, 0, 1, CFG.minH, CFG.maxH),
      CFG.minH, CFG.maxH
    );
    Target[i] = t;
    if(Math.abs(t - H[i]) < 1e-3){ Done[i]=1; doneCount++; }
  }
}
prepareTransition(nextWave);

// ===================== BUCLE =====================
let t0 = performance.now()/1000;
let spawnAcc = 0;

function animate(){
  const t = performance.now()/1000; const dt = Math.min(0.033, t - t0); t0 = t;

  // Cámara (rotación lenta fija, sin inputs)
  camAngle += CAM.autorotate * dt;
  placeCamera();

  // Spawning por lotes (aleatorio, limitado)
  spawnAcc += CFG.spawnPerSec * dt;
  let budget = Math.floor(spawnAcc);
  if(budget>0) spawnAcc -= budget;
  if(activeCount < CFG.maxConcurrent){
    const canAdd = Math.min(budget, CFG.maxConcurrent - activeCount);
    let attempts = 0, added = 0;
    while(added < canAdd && attempts < canAdd*12){
      const i = (Math.random()*COUNT)|0;
      if(!Active[i] && !Done[i]){
        const diff = Target[i] - H[i];
        if(Math.abs(diff) < 1e-3){ Done[i]=1; doneCount++; }
        else{
          Active[i]=1;
          activeList[activeLen++] = i;
          activeCount++;
          setOverride(i, 1, diff>0 ? CFG.riseRGB : CFG.dropRGB); // verde si sube, rojo si baja
        }
        added++;
      }
      attempts++;
    }
    if(added>0){ overrideAttr.needsUpdate = true; ovColorAttr.needsUpdate = true; }
  }

  // Avance de las activas (lento, color mantenido)
  let anyMatrixChange = false;
  for(let idx=0; idx<activeLen; idx++){
    const i = activeList[idx];
    const diff = Target[i] - H[i];
    const stepH = CFG.speed * dt;
    if(Math.abs(diff) <= stepH){
      H[i] = Target[i];
      setInstance(i, H[i]);
      anyMatrixChange = true;
      setOverride(i, 0); // volver a color normal al llegar
      overrideAttr.needsUpdate = true;
      Active[i]=0; Done[i]=1; doneCount++;
      activeList[idx] = activeList[--activeLen];
      idx--; activeCount--;
    }else{
      H[i] += Math.sign(diff) * stepH;
      setInstance(i, H[i]);
      anyMatrixChange = true;
    }
  }
  if(anyMatrixChange) mesh.instanceMatrix.needsUpdate = true;

  // Encadenar ondas 1→2→3→1 cuando todos llegan
  if(doneCount >= COUNT){
    currentWave = nextWave;
    nextWave = (nextWave + 1) % WAVES.length;
    prepareTransition(nextWave);
  }

  renderer.render(scene, camera);
  requestAnimationFrame(animate);
}
requestAnimationFrame(animate);

// ===================== RESIZE =====================
addEventListener('resize', ()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.fov = THREE.MathUtils.clamp(CAM.fov, CAM.minFov, CAM.maxFov);
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
</script>
</body>
</html>
